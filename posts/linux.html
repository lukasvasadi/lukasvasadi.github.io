<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Lukas Vasadi</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="../css/styles.css" />
</head>

<body>
    <nav>
        <a href="../index.html" class="code-text">lukasvasadi</a>
        <div id="desktop-menu">
            <a href="../about.html">About</a>
            <a href="../gallery.html">Gallery</a>
            <a href="mailto:lukas.vasadi@gmail.com"><i class="fa fa-envelope"></i></a>
        </div>
        <!-- Hamburger menu -->
        <a href="javascript:void(0);" class="hamburger" onclick="menuFunction()"><i class="fa fa-bars"></i></a>
    </nav>
    <div id="mobile-menu">
        <a href="../about.html">About</a>
        <a href="../gallery.html">Gallery</a>
        <a href="lukas.vasadi@gmail.com" class="icon"><i class="fa fa-envelope"></i></a>
    </div>
    <main> 
        <h1 class="center extra-padding">Mastering the Linux command line interface</h1>
        <h4 class="center">Last updated: September 2021</h4>
        <article>
            <div class="toc">
                <div class="fixed">
                    <h3>Contents</h3>
                    <ul>
                        <li><a href="#basic-utilities">Basic utilities</a></li>
                        <li><a href="#pipeline">Command pipeline</a></li>
                        <li><a href="#filesystem-nav">Navigating the filesystem</a></li>
                        <li><a href="#working-files">Working with files</a></li>
                        <li><a href="#searching-files">Searching for files</a></li>
                        <li><a href="#package-managers">Package managers</a></li>
                        <li><a href="#documentation">Accessing documentation</a></li>
                        <li><a href="#processes">Processes</a></li>
                        <li><a href="#file-operations">File operations</a></li>
                        <li><a href="#text-editors">Text editors</a></li>
                    </ul>
                </div>
            </div>
            <div class="content">
                <section class="code-section">
                    <h3 id="basic-utilities">Basic utilities</h3>
                    <div class="grid definitions">
                        <p><span class="code-snippet">cat</span></p><p>type out a file (or combine files)</p>
                        <p><span class="code-snippet">head</span></p><p>show first few lines of file</p>
                        <p><span class="code-snippet">tail</span></p><p>show last few lines of file</p>
                        <p><span class="code-snippet">less</span></p><p>view contents of larger files with scroll-back</p>
                        <p><span class="code-snippet">man</span></p><p>view documentation</p>
                        <p><span class="code-snippet">sudo</span></p><p>grant admin privileges</p>
                        <p><span class="code-snippet">|</span></p><p>pipe data between programs</p>
                        <p><span class="code-snippet">ssh</span></p><p>secure shell remote machine</p>
                        <p><span class="code-snippet">pwd</span></p><p>print working directory</p>
                        <p><span class="code-snippet">cd</span></p><p>change directory</p>
                    </div>
                    <p>
                        The command is the name of the program being executed. Many commands accept arguments and 
                        options, the latter often preceded with one or two dashes, e.g., 
                        <span class="code-snippet">-p</span> or <span class="code-snippet">--print</span>, to be
                        distinguishable.
                    </p>
                    <p>
                        Users have several options to shutdown or reboot the system from the command line:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># power off system without rebooting</p>
                        <p>sudo shutdown -h</p>
                        <p class="code-comment"># alternative commands that issue shutdown</p>
                        <p>sudo halt</p>
                        <p>sudo poweroff</p>
                        <p class="code-comment"># reboot the system</p>
                        <p>sudo shutdown -r</p>
                        <p class="code-comment"># reboot alternative</p>
                        <p>sudo reboot</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="pipeline">Command pipeline</h3>
                    <p>
                        The Unix/Linux philosophy is to combine multiple short programs to produce complex results. To achieve this 
                        coordination, data (output) from one program may be "piped" into another using the <span class="code-snippet">|</span>
                        command. A string of connected commands is called a pipeline.
                    </p>
                    <div class="code-block">
                        <p>command1 | command2 | command3</p>
                    </div>
                    <p>
                        In the above example, <span class="code-snippet">command2</span> and <span class="code-snippet">command3</span> can start
                        acting on output from previous commands in the pipeline while those commands are still being executed. This feature utilizes
                        the multicore functionality of modern computer systems and does not require data to be written to temporary files.
                    </p>
                </section>
                <section class="code-section">
                    <h3 id="filesystem-nav">Filesystem navigation</h3>
                    <p>
                        Locate programs with the <span class="code-snippet">which</span> or 
                        <span class="code-snippet">whereis</span> utilities, the latter of which searches
                        across a broader range of system directories and also prints the location of the 
                        <span class="code-snippet">man</span> page:
                    </p>
                    <div class="code-block">
                        <p>which program</p>
                        <p>whereis program</p>
                    </div>
                    <p>Use <span class="code-snippet">cd</span> to navigate directories:</p>
                    <div class="code-block">
                        <p class="code-comment"># change to home directory</p>
                        <p>cd</p>
                        <p>cd ~</p>
                        <p class="code-comment"># change to root directory</p>
                        <p>cd /</p>
                        <p class="code-comment"># change to parent directory</p>
                        <p>cd ..</p>
                        <p class="code-comment"># change to previous directory</p>
                        <p>cd -</p>
                    </div>
                    <p>
                        When referencing pathnames, remember that absolute pathnames must be preceded by 
                        <span class="code-snippet">/</span>:
                    </p>
                    <div class="code-block">
                        <p>cd /usr/bin</p>
                        <p>cd ../../usr/bin</p>
                    </div>
                    <p>
                        Use the <span class="code-snippet">tree</span> command to view the entire filesystem
                        (note that this command may have to be installed with <span class="code-snippet">snap</span>):
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># the -d option displays directories while suppressing file names</p>
                        <p>tree -d</p>
                    </div>
                    <p>The <span class="code-snippet">ls</span> command lists the contents of the working directory:</p>
                    <div class="code-block">
                        <p>ls</p>
                        <p class="code-comment"># present in list view</p>
                        <p>ls -l</p>
                        <p class="code-comment"># include hidden files</p>
                        <p>ls -a</p>
                    </div>
                    <p>
                        Use <span class="code-snippet">pushd</span> to navigate the filesystem and store visited directories
                        to a stack for later reference:
                    </p>
                    <div class="code-block">
                        <p>pwd</p>
                        <p class="terminal-output">/usr</p>
                        <p>pushd bin</p>
                        <p class="terminal-output">/usr/bin /usr</p>
                    </div>
                    <p>
                        Similarly, use <span class="code-snippet">popd</span> to revisit previous directories in reverse order. 
                        The <span class="code-snippet">dirs</span> command prints a list of recent directories stacked with <span class="code-snippet">pushd</span>.
                    </p>
                </section>
                <section class="code-section">
                    <h3 id="working-files">Working with files</h3>
                    <p>There are many command line utilities for viewing and reconfiguring files.</p>
                    <div class="code-block">
                        <p class="code-comment"># load file contents in terminal window</p>
                        <p>cat filename</p>
                        <p class="code-comment"># load file contents with line numbers</p>
                        <p>cat -n filename</p>
                        <p class="code-comment"># load file contents in reverse</p>
                        <p>tac filename</p>
                    </div>
                    <p>
                        To see one page of text at a time, use the <span class="code-snippet">less</span> command and press the 
                        spacebar to move through the file.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># show one page of text</p>
                        <p>less filename</p>
                        <p class="code-comment"># show one page of text with line numbers</p>
                        <p>less -N filename</p>
                    </div>
                    <p>
                        The <span class="code-snippet">head</span> and <span class="code-snippet">tail</span> commands display the
                        first or last 10 lines of a file, respectively.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># show first 10 lines</p>
                        <p>head filename</p>
                        <p class="code-comment"># specify number of lines</p>
                        <p>head -20 filename</p>
                        <p class="code-comment"># show last 10 lines</p>
                        <p>tail filename</p>
                        <p class="code-comment"># specify number of lines</p>
                        <p>tail -20 filename</p>
                    </div>
                    <p>
                        The <span class="code-snippet">touch</span> utility is commonly used to create new files for later usage, but 
                        can also update/modify the timestamp of an existing file.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># create new file in current directory</p>
                        <p>touch filename</p>
                        <p class="code-comment"># update the date and timestamp of an existing file</p>
                        <p>touch filename</p>
                        <p class="code-comment"># modify the date and timestamp of an existing file MM DD TIME</p>
                        <p>touch -t 01011200 filename</p>
                    </div>
                    <p>
                        Use <span class="code-snippet">mkdir</span> and <span class="code-snippet">rmdir</span> to manage directories.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># create new local directory</p>
                        <p>mkdir dirname</p>
                        <p class="code-comment"># create new directory with specific path</p>
                        <p>mkdir dirpath</p>
                        <p class="code-comment"># delete an empty directory</p>
                        <p>rm dirname</p>
                        <p class="code-comment"># delete a directory with contents</p>
                        <p>rm -rf dirname</p>
                    </div>
                    <p>
                        The <span class="code-snippet">mv</span> utility can both rename and relocate files.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># rename existing file</p>
                        <p>mv filename new-filename</p>
                        <p class="code-comment"># relocate file</p>
                        <p>mv filename new-filepath</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="searching-files">Searching for files</h3>
                    <p>
                        When interacting with the command line, there are always three standard file streams in operation:
                        <span class="code-snippet">stdin</span>, <span class="code-snippet">stdout</span>, and 
                        <span class="code-snippet">stderr</span>. Usually, <span class="code-snippet">stdin</span> captures
                        user input while <span class="code-snippet">stdout</span> and <span class="code-snippet">stderr</span>
                        print feedback via the terminal, though <span class="code-snippet">stderr</span> often targets an error
                        logging file. The user can redirect these file streams to pipe data between various files and programs.
                    </p>
                    <p>
                        The input source and output destination of a program can be changed with the 
                        <span class="code-snippet">&lt;</span> and <span class="code-snippet">&gt;</span> symbols, respectively:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># redirect program input</p>
                        <p>do_something &lt; input-file</p>
                        <p class="code-comment"># send output to file</p>
                        <p>do_something &gt; output-file</p>
                        <p class="code-comment"># send stderr output to file</p>
                        <p>do_something 2&gt; output-file</p>
                        <p class="code-comment"># send all output to same destination file</p>
                        <p>do_something &gt; output-file 2&gt;&amp;1</p>
                        <p class="code-comment"># shorthand syntax</p>
                        <p>do_something &gt;&amp; output-file</p>
                    </div>
                    <p>
                        To search for files and directories that contain a specific string, use the <span class="code-snippet">locate</span>
                        command in combination with <span class="code-snippet">grep</span> for further filtering. Alternatively, the 
                        <span class="code-snippet">find</span> command can be used to locate files (or directories) after specifying the search 
                        directory, where working directory is the default, and adding the <span class="code-snippet">-name</span> parameter alongside
                        the search string. Note: without any arguments, <span class="code-snippet">-name</span> outputs all files in the current and 
                        nested directories.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># list all files with zip and bin in their name</p>
                        <p>locate zip | grep bin</p>
                        <p class="code-comment"># use find to search for a file in the current working directory</p>
                        <p>find . -name "zip"</p>
                    </div>
                    <p>
                        With these commands, it is often useful to employ wildcards:
                    </p>
                    <div class="grid definitions">
                        <p><span class="code-snippet">?</span></p><p>match any single character</p>
                        <p><span class="code-snippet">*</span></p><p>match any string of characters</p>
                        <p><span class="code-snippet">[set]</span></p><p>match any character in set, e.g., [adf]</p>
                        <p><span class="code-snippet">[!set]</span></p><p>match any character not in set</p>
                    </div>
                    <p>
                        For example, to find a file that has "ba" followed by a third unknown character, with extension .out,
                        search for <span class="code-snippet">ba?.out</span>. Similarly, if the entire name is unknown, search
                        for <span class="code-snippet">*.out</span>. Putting the search criteria in quotes will expand the search
                        beyond the working directory: <span class="code-snippet">ls "*.out"</span>.
                    </p>
                    <p>
                        Using the <span class="code-snippet">-exec</span> parameter, the <span class="code-snippet">find</span> utility can also run other
                        commands on the search results:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># find and remove all files with extension .swp</p>
                        <p>find -name "*.swp" -exec rm {} ';'</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="package-managers">Package managers</h3>
                    <p>
                        There are two broad families of package managers for Debian and RPM distributions. Each family has a high-level tool, 
                        e.g., <span class="code-snippet">apt</span>, <span class="code-snippet">dnf</span>, <span class="code-snippet">zypper</span>, 
                        that manage low-level utilities, e.g., <span class="code-snippet">dpkg</span>, <span class="code-snippet">rpm</span>, which 
                        are responsible for unpacking and installing individual packages. These high-level tools also coordinate the installation of 
                        dependencies, or packages that are needed to support the current installation.
                    </p>
                    <p>
                        Some common package management commands for Debian-based distros include:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># list all packages on system</p>
                        <p>dpkg --list</p>
                        <p class="code-comment"># install (or update) package and dependencies</p>
                        <p>apt-get install foo</p>
                        <p class="code-comment"># remove package and dependencies</p>
                        <p>apt-get remove foo</p>
                        <p class="code-comment"># upgrade entire system</p>
                        <p>apt-get dist-upgrade</p>
                        <p class="code-comment"># search packages named foo</p>
                        <p>apt-cache search foo</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="documentation">Accessing documentation</h3>
                    <p>
                        The general philosophy of computer administration is to not memorize every single shell command along with its parameters. Instead,
                        administrators can reference the <span class="code-snippet">man</span> pages&mdash;short for manual&mdash; or utilize either the 
                        <span class="code-snippet">help</span> command or <span class="code-snippet">--help</span> option.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># find information about a specific topic</p>
                        <p>man topic</p>
                        <p class="code-comment"># list all pages on topic</p>
                        <p>man -f topic</p>
                        <p class="code-comment"># alternatively...</p>
                        <p>whatis topic</p>
                        <p class="code-comment"># list all pages that discuss a topic (yields more results)</p>
                        <p>man -k topic</p>
                        <p class="code-comment"># alternatively...</p>
                        <p>apropos topic</p>
                    </div>
                    <p>
                        While <span class="code-snippet">man</span> is a great tool for reading detailed information about specific utilities, often administrators
                        only need a brief description. This can be accomplished using <span class="code-snippet">--help</span> or <span class="code-snippet">-h</span>:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># find information on the man command</p>
                        <p>man --help</p>
                    </div>
                    <p>
                        Typing <span class="code-snippet">help</span> at the command line will print consolidated information about built-in commands.
                    </p>
                </section>
                <section class="code-section">
                    <h3 id="processes">Processes</h3>
                    <p>
                        A process represents a current task running on the computer. Single commands may launch one or more processes simultaneously. The operating
                        system is responsible for allocating system resources to each process for optimized performance. There are several types of processes:
                    </p>
                    <ul>
                        <li><span class="emph">Interactive:</span> started by the user via the command line or graphical interface</li>
                        <li><span class="emph">Batch:</span> automated processes that require queued resource allocation on a first-in, first-out (FIFO) basis</li>
                        <li><span class="emph">Daemons:</span> server processes that run continuously in the background</li>
                        <li><span class="emph">Threads:</span> lightweight processes that run under a main process, sharing a designated number of resources</li>
                        <li><span class="emph">Kernel threads:</span> perform housekeeping tasks such as relocating threads between CPU cores</li>
                    </ul>
                    <p>
                        The kernel <span class="emph">scheduler</span> allocates CPU time to queued processes. Each CPU core has a run and wait queue. When a process
                        enters a <span class="emph">sleep</span> state, the scheduler moves it to the wait queue until the necessary feedback is received. To manage 
                        process scheduling and resource allocation, the operating system assigns each running process a unique process ID <span class="emph">(PID)</span> 
                        number, which Usually follow the order that each process was born in the system. In addition, each process has a parent process ID 
                        <span class="emph">(PPID)</span> and, if the process is multithreaded, a unique thread ID <span class="emph">(TID)</span>.
                    </p>
                    <p>
                        Users can terminate processes in the terminal shell:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># kill process</p>
                        <p>kill -SIGKILL pid</p>
                        <p class="code-comment"># alternatively</p>
                        <p>kill -9 pid</p>
                    </div>
                    <p>
                        Users can also specify a <span class="emph">nice value</span> for individual processes to control their execution priority. The lower the nice value,
                        the more preference will be given this process over system resources and runtime. Linux nice values range from -20 to +19, with -20 designating the 
                        highest priority, or precedence. Note that changing the niceness of a process will also update any child processes with the same value. Increasing
                        niceness may require superuser permissions.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># change the niceness value</p>
                        <p>renice value pid</p>
                    </div>
                    <p>
                        The <span class="emph">load average</span> breaks down CPU resource consumption over three specified timepoints: 45, 15, and 5 min. These percentages 
                        denote the amount of CPU resources demanded by active processes. For example, a load average of 0.5 means that an average of 50% CPU resources were 
                        consumed for the specified time period.
                    </p>
                    <p>
                        With modern machines, each load average should be divided by the number of CPU cores, e.g., a load average of 2.0
                        for a dual-core system indicates 100% CPU resource consumption. It is possible for normalized load averages to exceed 1.0 for brief periods, but prolonged
                        over-utilization may suggest problems. Load averages may be viewed in the terminal by running either <span class="code-snippet">w</span>, 
                        <span class="code-snippet">top</span>, or <span class="code-snippet">uptime</span>.
                    </p>
                    <p>
                        Jobs, or terminal commands, may be run in the foreground or background. Foreground jobs may be suspended with <span class="code-snippet">CTRL-Z</span> or
                        terminated with <span class="code-snippet">CTRL-C</span>. Suffixing a command with <span class="code-snippet">&</span> causes it to be executed in the background.
                        Alternatively, the <span class="code-snippet">bg</span> and <span class="code-snippet">fg</span> commands can push jobs to the background or foreground, 
                        respectively.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># view active background jobs</p>
                        <p>jobs</p>
                    </div>
                    <p>
                        The <span class="code-snippet">ps</span> command prints information about current running processes:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># display all processes running under current shell</p>
                        <p>ps</p>
                        <p class="code-comment"># include PPID</p>
                        <p>ps -f</p>
                        <p class="code-comment"># include full system detail</p>
                        <p>ps -ef</p>
                        <p class="code-comment"># show one line of information for every thread</p>
                        <p>ps -elf</p>
                        <p class="code-comment"># display as tree diagram to show process lineage</p>
                        <p>pstree</p>
                    </div>
                    <p>
                        In addition to printing load averages, the <span class="code-snippet">top</span> command presents a real-time system monitor of all processes, listed in order of 
                        CPU resource consumption. The list constantly updates until the user quites with <span class="code-snippet">q</span>. Other interactive options for top include:
                    </p>
                    <div class="grid definitions">
                        <p><span class="code-snippet">t</span></p><p>show or hide summary</p>
                        <p><span class="code-snippet">m</span></p><p>show or hide memory</p>
                        <p><span class="code-snippet">A</span></p><p>sort list by highest resource consumers</p>
                        <p><span class="code-snippet">r</span></p><p>renice specific process</p>
                        <p><span class="code-snippet">k</span></p><p>kill specific process</p>
                        <p><span class="code-snippet">f</span></p><p>enter configuration utility</p>
                    </div>
                    <p>
                        Various commands exist to manage future program execution and suspend currently active processes:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># schedule non-interactive process to execute in 10 minutes</p>
                        <p>at now + 10 minutes</p>
                        <p class="code-comment"># issue command to be executed, then press CTRL-D to exit at config</p>
                        <p>command arguments</p>
                        <p class="code-comment"># sleep active program for 10 seconds</p>
                        <p>sleep 10s</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="file-operations">File operations</h3>
                    <p>
                        In the Linux, the root directory, denoted by <span class="code-snippet">/</span>, represents the beginning of the filesystem hierarchy. There are 
                        many types of filesystems, which often differ across operating systems, but the most common belong to the <span class="emph">journaling</span> variety:
                        ext4, xfs, btrfs, jfs. It is often the case that an OS will have several different filesystems, each stored on a particular disk partition. Important 
                        programs to run the system are isolated on the <span class="emph">root</span> partition. Each partition has to be mounted on the filesystem tree to be 
                        accessible by the user. Examples of common mount points, which appear as empty directories, include <span class="code-snippet">/</span>, 
                        <span class="code-snippet">/home</span>, and <span class="code-snippet">/var</span>.
                    </p>
                    <p>
                        Partitions can be mounted through a graphical utility, such as <span class="emph">gparted</span>, or the command line with the device node and mount 
                        point as the arguments:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># mount the filesystem at device node /dev/sda5 into the main filesystem tree at mount point /home</p>
                        <p>sudo mount /dev/sda5 /home</p>
                        <p class="code-comment"># unmount the partition</p>
                        <p>sudo umount /home</p>
                        <p class="code-comment"># show all mounted filesystems</p>
                        <p>mount</p>
                    </div>
                    <p>
                        Filesystems and data can also be shared across machines through networks. Networks, accessible over the internet, allow grouping of lower-level filesystems
                        into a more universal framework, e.g., the Network Filesystem (<span class="emph">NFS</span>). For all intensive purposes, NFS can be treated as an other filesystem 
                        on the client or server side.
                    </p>
                    <p>
                        Each user has a home directory listed under <span class="code-snippet">/home</span>. The <span class="code-snippet">/root</span> directory is simply the home of the 
                        root user (aka superuser or system administrator). The <span class="code-snippet">/bin</span> directory contains executable binaries needed to boot the system as well 
                        as ubiquitous user commands, such as <span class="code-snippet">cat</span>, <span class="code-snippet">cp</span>, <span class="code-snippet">ls</span>, etc. Though 
                        similar, <span class="code-snippet">/sbin</span> stores executables for system administration, such as <span class="code-snippet">ip</span>.
                    </p>
                    <p>
                        Non-essential commands are stored under <span class="code-snippet">/usr/bin</span> and <span class="code-snippet">/usr/sbin</span>, which was initially done to allow 
                        mounting of the user filesystem at a later stage in the OS startup. However, this practice is mostly considered obselete and, as such, most modern Linux distros symbolically 
                        link <span class="code-snippet">/usr/bin</span> with <span class="code-snippet">/bin</span> and <span class="code-snippet">/usr/sbin</span> with <span class="code-snippet">/sbin</span>, 
                        i.e., for all intensive purposes, there are no distinctions between these directory groupings.
                    </p>
                    <p>
                        The <span class="code-snippet">/proc</span> filesystem contains <span class="emph">virtual files</span>&mdash;files that only exist in memory&mdash;that track dynamic kernel 
                        data, including information about mounted devices, hardware configurations, CPU, etc. This directory is considered a <span class="emph">pseudo filesystem</span> because it occupies 
                        no permanent space in storage.
                    </p>
                    <p>
                        The <span class="code-snippet">/dev</span> directory becomes populated with <span class="emph">device nodes</span> as devices, e.g., printers, are connected to the computer. Similarly, 
                        <span class="code-snippet">/var</span> is a dynamic directory of sorts as it contains files that are expected to change in size, e.g., system log files (<span class="code-snippet">/var/log</span>), 
                        packages and database files (<span class="code-snippet">/var/lib</span>), and temporary files (<span class="code-snippet">/var/tmp</span>).
                    </p>
                    <p>
                        The <span class="code-snippet">/etc</span> directory is home to system configuration files that can only be modified by the superuser. Likewise, the <span class="code-snippet">/boot</span> 
                        directory contains essential files needed to boot the system, which are kernel-specific. Libraries needed for binary executables are stored in <span class="code-snippet">/lib</span> 
                        (32-bit) and <span class="code-snippet">/lib64</span> (64-bit). Removable media files, such as the contents of a connected USB drive, are typically accessible 
                        uner the <span class="code-snippet">/run/media/usrname/</span> directory.
                    </p>
                    <p>
                        There are other directories listed under <span class="code-snippet">/root</span>, as well as an entire directory tree under <span class="code-snippet">/usr</span> that contains 
                        a host of programs and scripts not needed to boot or manage the system. 
                    </p>
                    <p>
                        Comparing text files can be done with the <span class="code-snippet">diff</span> command:
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># compare differences between two text files</p>
                        <p>diff [options] filename1 filename2</p>
                        <p class="code-comment"># compare differences between three text files, with one acting as a reference</p>
                        <p>diff3 filename1 referencefile filename2</p>
                    </div>
                    <p>
                        This utility provides several options:
                    </p>
                    <div class="grid definitions">
                        <p><span class="code-snippet">-c</span></p><p>provide listing of differences</p>
                        <p><span class="code-snippet">-r</span></p><p>recursively compare subdirectories</p>
                        <p><span class="code-snippet">-i</span></p><p>ignore capitalization</p>
                        <p><span class="code-snippet">-w</span></p><p>ignore whitespace</p>
                        <p><span class="code-snippet">-q</span></p><p>state whether files are different without providing context</p>
                    </div>
                    <p>
                        Unlike other operating systems, Linux does not rely on file extensions to direct operations, e.g., a file with the <span class="code-snippet">.txt</span> 
                        extension could be a binary executable. Users can employ the <span class="code-snippet">file</span> utility to ascertain file type and other important 
                        information.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># ascertain file type</p>
                        <p>file filename</p>
                        <p class="code-comment"># find detailed information about all files in working directory</p>
                        <p>file *</p>
                    </div>
                    <p>
                        Data can be backed up using the <span class="code-snippet">cp</span> or <span class="code-snippet">rsync</span> utilities. While 
                        the <span class="code-snippet">cp</span> command copies files from one destination to another on a local machine, <span class="code-snippet">rsync</span> 
                        performs recursive operations to only copy modified data, i.e., existing files may not be entirely overwritten. The <span class="code-snippet">rsync</span> 
                        utility can also copy data across remote machines.
                    </p>
                    <div class="code-block">
                        <p class="code-comment"># copy file to new location</p>
                        <p>rsync sourcefile destinationfile</p>
                        <p class="code-comment"># back up project data to remote archive</p>
                        <p>rsync -r project networked-machine:archives/project</p>
                        <p class="code-comment"># perform a dry run to prevent unwanted overwrites</p>
                        <p>rsync -r -dry-run project networked-machine:archives/project</p>
                    </div>
                    <p>
                        There are several Linux utilities for managing data compression: <span class="code-snippet">gzip</span>, 
                        <span class="code-snippet">bzip2</span> (deprecated), <span class="code-snippet">xz</span>. Each of 
                        these utilities employ different compression algorithms and, not surprisingly, the utilities which 
                        produce smaller files require longer amounts of time. A similar program, <span class="code-snippet">tar</span>, 
                        compresses files grouped in an archive. Lastly, <span class="code-snippet">zip</span> is a legacy utility 
                        specifically used to decompress zipped files from a Windows machine&mdash;though it also has compression 
                        functionality.
                    </p>
                    <div class="code-block">
                        <p><span class="code-comment"># compress files in current directory</span></p>
                        <p>gzip *</p>
                        <p><span class="code-comment"># recursively compress files in specified project directory</span></p>
                        <p>gzip -r projectdir</p>
                        <p><span class="code-comment"># decompress file foo.gz</span></p>
                        <p>gzip -d foo</p>
                        <p>gunzip foo</p>
                    </div>
                </section>
                <section class="code-section">
                    <h3 id="text-editors">Text editors</h3>
                    <p>
                        There are several ways to create and edit text files from the command line:
                    </p>
                    <div class="code-block">
                        <p><span class="code-comment"># write several lines to a text file</span></p>
                        <p>echo line one > filename</p>
                        <p><span class="code-comment"># note that >> appends output to file</span></p>
                        <p>echo line two >> filename</p>
                        <p>echo line three >> filename</p>
                        <p><span class="code-comment"># alternatively use cat with redirection</span></p>
                        <p>cat << EOF > file</p>
                        <p>line one</p>
                        <p>line two</p>
                        <p>line three</p>
                        <p>EOF</p>
                    </div>
                    <p>
                        For more flexible text editing, Linux distros offer several terminal-based and graphical editors, 
                        including <span class="emph">nano</span>, <span class="emph">gedit</span>, <span class="emph">vi</span>,
                        and <span class="emph">emacs</span>. The nano and gedit editors can be invoked with the 
                        <span class="code-snippet">nano</span> and <span class="code-snippet">gedit</span> commands, 
                        respectively.
                    </p>
                    <p>
                        In most modern GNOME distros, vi is accessible with vim, which stands for <span class="emph">V</span>i 
                        <span class="emph">IM</span>proved. Though vi has a steep learning curve for new users, it is significantly 
                        more powerful than nano and gedit. Invoking <span class="code-snippet">vimtutor</span> from the command 
                        line will launch a vim tutorial.
                    </p>
                    <p>
                        Vi has three different modes:
                    </p>
                    <div class="grid definitions">
                        <p><span class="code-snippet">command</span></p><p>default mode where each key is an editor command</p>
                        <p><span class="code-snippet">insert</span></p><p>insert text into file (invoked with <span class="code-snippet">i</span>)</p>
                        <p><span class="code-snippet">line</span></p><p>each key is an external command, though many are now deprecated (invoked with <span class="code-snippet">:</span>)</p>
                    </div>
                    <p>
                        Some of the most useful commands for vi include:
                    </p>
                    <div class="grid definitions">
                        <p><span class="code-snippet">vi file</span></p><p>open file in editor</p>
                        <p><span class="code-snippet">vi -r file</span></p><p>open file in recovery mode after system crash</p>
                        <p><span class="code-snippet">:r file2</span></p><p>read in a second file and insert at current position</p>
                        <p><span class="code-snippet">:w</span></p><p>write to file</p>
                        <p><span class="code-snippet">:w file</span></p><p>write out to a new file</p>
                        <p><span class="code-snippet">:w! file2</span></p><p>overwrite file2</p>
                        <p><span class="code-snippet">:wq</span></p><p>write to file and exit</p>
                        <p><span class="code-snippet">:q</span></p><p>quit</p>
                        <p><span class="code-snippet">:q!</span></p><p>quit even with unsaved modifications</p>
                    </div>
                </section>
            </div>
        </article>
    </main>
    <footer>
        <p>Copyright &copy; 2021 Lukas Vasadi</p>
    </footer>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="../js/main.js"></script>
</body>

</html>